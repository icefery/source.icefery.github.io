---
title: 【排序】————十大经典排序算法
date: 2020-03-12 14:17:20
categories: 
- 算法
tags: 
- 排序
---

## 前言

排序算法在线模拟：[http://www.atool9.com/sort.php]( http://www.atool9.com/sort.php )

参考博客[超详细十大经典排序算法总结]( https://blog.csdn.net/weixin_41190227/article/details/86600821 )

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE3LmNuYmxvZ3MuY29tL2Jsb2cvODQ5NTg5LzIwMTcxMC84NDk1ODktMjAxNzEwMTUyMzMwNDMxNjgtMTg2NzgxNzg2OS5wbmc?x-oss-process=image/format,png)<br/><br/>


<!-- more -->

## 直接插入排序

```cpp
void straightInsertSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        if (arr[i] < arr[i - 1]) {
            int temp = arr[i];
            int j;
            for (j = i - 1; j >= 0 && arr[j] > temp; j--) {
                arr[j + 1] = arr[j];
            }
            arr[j + 1] = temp;
        }
    }
}
```

## 希尔排序

----

```cpp
void shellSort(int arr[], int n) {
    int index = n / 2;
    while (index >= 1) {
        for (int i = index; i < n; i++) {
            for (int j = i - index; j >= 0; j -= index) {
                if (arr[j] > arr[j + index]) {
                    int temp = arr[j];
                    temp = arr[j];
                    arr[j] = arr[j + index];
                    arr[j + index] = temp;
                }
            }
        }
        index = index / 2;
    }
}
```


## 直接选择排序

```cpp
void straightSelectSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int index = i;
        for (int j = i + 1; j <= n; j++) {
            if (arr[index] > arr[j]) {
                index = j;
            }
        }
        if (index != i) {
            int temp = arr[i];
            arr[i] = arr[index];
            arr[index] = temp;
        }
    }
}
```

## 简单选择排序

```cpp
void simpleSelectSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[min]) {
                min = j;
            }
        }
        int temp = arr[min];
        arr[min] = arr[i];
        arr[i] = temp;
    }
}
```


## 堆排序

<code>swap()</code>函数

```cpp
void swap(int arr[], int a, int b) {
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
```

<code>maxHeapify()</code>函数

```cpp
void maxHeapify(int arr[], int i, int n) {
    int child;
    int temp;
    for (temp = arr[i]; i * 2 + 1 < n; i = child) {
        child = i * 2 + 1;
        if (child != n - 1 && arr[child] < arr[child + 1]) {
            child++;
        }
        if (temp < arr[child]) {
            arr[i] = arr[child];
        } else {
            break;
        }
    }
    arr[i] = temp;
}
```

<code>heapSort()</code>函数

```cpp
void heapSort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        maxHeapify(arr, i, n);
    }
    for (int i = n - 1; i > 0; i--) {
        swap(arr, 0, i);
        maxHeapify(arr, 0, i);
    }
}
```



## 冒泡排序

```cpp
void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
```

优化

```cpp
void bubbleSort(int arr[], int n) {
    int lastExchangeIndex = 0;
    int sortBorder = n - 1;
    for (int i = 0; i < n - 1; i++) {
        bool sorted = true;
        for (int j = 0; j < sortBorder; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                sorted = false;
                lastExchangeIndex = j;
            }
        }
        sortBorder = lastExchangeIndex;
        if (sorted) {
            break;
        }
    }
}

```

## 快速排序

<code>partition()</code>函数——挖坑法

```cpp
int partition(int arr[], int startIndex, int endIndex) {
    int pivot = arr[startIndex];
    int left = startIndex;
    int right = endIndex;
    int index = startIndex;
    while (right >= left) {
        while (right >= left) {
            if (arr[right] < pivot) {
                arr[left] = arr[right];
                index = right;
                left++;
                break;
            }
            right--;
        }
        while (right >= left) {
            if (arr[left] > pivot) {
                arr[right] = arr[left];
                index = left;
                right--;
                break;
            }
            left++;
        }
    }
    arr[index] = pivot;
    return index;
}
```

<code>partition()</code>指针交换法

```cpp
int partition(int arr[], int startIndex, int endIndex) {
    int pivot = arr[startIndex];
    int left = startIndex;
    int right = endIndex;
    while (left != right) {
        while (left < right && arr[right] > pivot) {
            right--;
        }
        while (left < right && arr[left] <= pivot) {
            left++;
        }
        if (left < right) {
            int p = arr[left];
            arr[left] = arr[right];
            arr[right] = p;
        }
    }
    int p = arr[left];
    arr[left] = arr[startIndex];
    arr[startIndex] = p;
    return left;
}
```

<code>quickSort()</code>函数——递归算法

```cpp
void quickSort(int arr[], int startIndex, int endIndex) {
    if (startIndex >= endIndex) {
        return;
    }
    int pivotIndex = partition(arr, startIndex, endIndex);
    quickSort(arr, startIndex, pivotIndex - 1);
    quickSort(arr, pivotIndex + 1, endIndex);
}
```

## 归并排序

<code>merge()</code>函数

```cpp
void merge(int arr[], int left, int mid, int right, int temp[]) {
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid && j <= right) {
        if (arr[i] < arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }
    while (i <= mid) {
        temp[k++] = arr[i++];
    }
    while (j <= right) {
        temp[k++] = arr[j++];
    }
    k = 0;
    while (left <= right) {
        arr[left++] = temp[k++];
    }
}
```

<code>mergeSort()</code>函数

```cpp
void mergeSort(int arr[], int left, int right, int temp[]) {
    if (left < right) {
        int mid = (left + right) / 2;
        mergeSort(arr, left, mid, temp);
        mergeSort(arr, mid + 1, right, temp);
        merge(arr, left, mid, right, temp);
    }
}
```

## 基数排序

<code>maxCount()</code>函数

```cpp
int maxCount(int arr[], int n) {
    int max = 0;
    for (int i = 0; i < n; i++) {
        int count = 1;
        int temp = arr[i];
        while (temp / 10 != 0) {
            temp = temp / 10;
            count++;
        }
        if (count > max) {
            max = count;
        }
    }
    return max;
}
```

<code>radixSort()</code>函数

```cpp
void radixSort(int arr[], int n) {
    int max = maxCount(arr, n);
    int radix = 1;
    for (int i = 0; i < max; i++) {
        int count[10];
        int temp[10][n];
        for (int j = 0; j < 10; j++) {
            count[j] = 0;
        }
        for (int j = 0; j < 10; j++) {
            for (int k = 0; k < n; k++) {
                temp[j][k] = 0;
            }
        }
        for (int j = 0; j < n; j++) {
            int k = (arr[j] / radix) % 10;
            temp[k][count[k]] = arr[j];
            count[k]++;
        }
        int b = 0;
        for (int j = 0; j < 10; j++) {
            if (count[j] > 0) {
                for (int k = 0; k < count[j]; k++) {
                    arr[b] = temp[j][k];
                    b++;
                }
            }
        }
        radix = radix * 10;
    }
}
```

## 桶排序

<code>getMax()</code>函数

```cpp
int getMax(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}
```

<code>bucketSort()</code>函数

```cpp
void bucketSort(int arr[], int n) {
    int max = getMax(arr, n) + 1;
    int buckets[max];
    for (int i = 0; i < max; i++) {
        buckets[i] = 0;
    }
    for (int i = 0; i < n; i++) {
        buckets[arr[i]]++;
    }
    for (int i = 0, j = 0; i < max; i++) {
        while (buckets[i] != 0) {
            arr[j] = i;
            j++;
            buckets[i]--;
        }
    }
}
```

## 计数排序

```cpp
void countSort(int arr[], int n) {
    int max = arr[0];
    int min = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
        if (arr[i] < min) {
            min = arr[i];
        }
    }
    int size = max - min + 1;
    int count[size];
    memset(count, 0, sizeof(int) * size);
    for (int i = 0; i < n; i++) {
        count[arr[i] - min]++;
    }
    for (int i = 1; i < size; i++) {
        count[i] += count[i - 1];
    }
    int sortedArray[n];
    memset(sortedArray, 0, sizeof(int) * n);
    for (int i = n - 1; i >= 0; i--) {
        count[arr[i] - min]--;
        sortedArray[count[arr[i] - min]] = arr[i];
    }
    for (int i = 0; i < n; i++) {
        arr[i] = sortedArray[i];
    }
}
```

